<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MEGAMICRODAW // v6.0_FINAL_INTEGRATED</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root { 
            --bg: #121418; 
            --panel: #1b1e26; 
            --surface: #232730;
            --text: #aab2c0; 
            --accent: #3498db; 
            --accent-glow: rgba(52, 152, 219, 0.4);
            --danger: #e74c3c; 
            --rec: #ff4757; 
            --step-off: #2c313a; 
            --step-on: #3498db;
            --playhead-color: #2ecc71;
            --btn-grad-top: #3a404b;
            --btn-grad-bot: #2c313a;
        }

        /* FULL SCREEN SETUP */
        html, body { 
            height: 100%; overflow: hidden; background: #000; 
            color: var(--text); font-family: 'Segoe UI', Roboto, sans-serif; 
            text-transform: uppercase; margin: 0; padding: 0; user-select: none; 
        }
        
        #chassis { 
            display: flex; flex-direction: column; height: 100vh; width: 100vw;
            background: var(--bg); padding: 10px; box-sizing: border-box; gap: 10px;
        }

        .panel { 
            border: 1px solid #000; background: var(--panel); border-radius: 4px; 
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3); flex-shrink: 0; 
        }
        
        /* TOP CONTROL BAR */
        #top-bar { padding: 10px; display: flex; justify-content: space-between; align-items: center; }

        /* MAIN SEQ AREA */
        #page-seq { display: flex; flex-direction: column; flex-grow: 1; min-height: 0; gap: 10px; }
        #bank-nav { padding: 8px; display: flex; gap: 5px; }

        /* TRACK RACK CONTAINER */
        #track-rack-container {
            display: flex; flex-direction: column; flex-grow: 1; min-height: 0;
            background: var(--surface); border: 1px solid #000; border-radius: 4px;
        }

        /* TOOLBAR (Controls Only) */
        #track-toolbar {
            padding: 8px 10px;
            background: #1e222b;
            border-bottom: 1px solid #000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* TIMELINE HEADER (Grid Synced) */
        #timeline-header {
            display: grid; 
            grid-template-columns: 100px 1fr 80px 30px; 
            gap: 8px;
            padding: 5px;
            padding-bottom: 10px;
            background: #1e222b;
            border-bottom: 1px solid #333;
            align-items: end; 
        }

        /* TRACK ROWS */
        .track-row { 
            display: grid; 
            grid-template-columns: 100px 1fr 80px 30px; 
            gap: 8px; 
            margin-bottom: 4px; 
            align-items: center; 
            background: #181b21; 
            padding: 5px; 
            border-radius: 3px; 
            border: 1px solid #000;
        }

        /* SCROLL AREA */
        #tracks-scroll-area { flex-grow: 1; overflow-y: auto; padding: 10px; }
        #tracks-scroll-area::-webkit-scrollbar { width: 10px; }
        #tracks-scroll-area::-webkit-scrollbar-track { background: #111; }
        #tracks-scroll-area::-webkit-scrollbar-thumb { background: #444; border-radius: 5px; border: 2px solid #111; }

        /* GRIDS & STEPS */
        .step-grid { display: grid; grid-template-columns: repeat(32, 1fr); gap: 2px; width: 100%; height: 100%; }
        
        .step { height: 24px; border-radius: 2px; cursor: pointer; background: var(--step-off); transition: background 0.1s; }
        .step.on { background: var(--step-on); box-shadow: 0 0 8px var(--accent-glow); }
        .step.beat-mark { border-left: 1px solid #555; }

        /* GLOWING DOT PLAYHEAD */
        .playhead-slot { 
            width: 6px; height: 6px; background: #333; border-radius: 50%; margin: auto; transition: all 0.05s;
        }
        .playhead-slot.active { 
            background: var(--playhead-color); 
            box-shadow: 0 0 8px var(--playhead-color), 0 0 15px var(--playhead-color); 
            transform: scale(1.5); 
        }

        /* SONG ARRANGER */
        #song-arranger-panel { padding: 10px; flex-shrink: 0; background: var(--panel); }
        #song-arranger-box { background:#111; padding:8px; margin-top:5px; overflow-x:auto; border-radius: 3px; display: flex; gap: 5px; align-items: center; }
        #song-cells button { width: 30px; padding: 5px 0; }

        /* MIXER */
        #page-mix { flex-grow: 1; display: none; flex-direction: column; min-height: 0; }
        .mixer-rack { display: grid; grid-template-columns: repeat(8, 1fr); gap: 8px; flex-grow: 1; padding: 10px; background: #111; border: 1px solid #000; border-radius: 4px; }
        .mixer-strip { border: 1px solid #333; padding: 10px; background: #1a1d23; border-radius: 4px; display: flex; flex-direction: column; }
        .fx-stack { flex-grow: 1; margin: 10px 0; border: 1px inset #000; background: #0d0f12; padding: 5px; overflow-y: auto; }

        /* UTILS */
        .flex { display: flex; gap: 10px; align-items: center; }
        .ctrl-group { border-right: 1px solid #333; padding-right: 15px; margin-right: 5px; display: flex; align-items: center; gap: 15px; }
        .ctrl-group:last-child { border: none; }
        .mini-slider-box { display: flex; flex-direction: column; width: 100px; position: relative; top: -2px; }
        .mini-slider-box label { font-size: 9px; color: #666; margin-bottom: 4px; letter-spacing: 1px; font-weight: 600; }
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer; margin: 0; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #000; border-radius: 2px; border-bottom: 1px solid #333; }
        input[type=range]::-moz-range-track { width: 100%; height: 4px; background: #000; border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%; background: #ccc; margin-top: -4px; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        button { 
            background: linear-gradient(to bottom, var(--btn-grad-top), var(--btn-grad-bot));
            color: #fff; border: 1px solid #111; border-top: 1px solid #4a5160;
            cursor: pointer; padding: 8px 14px; font-size: 10px; font-weight: 600;
            border-radius: 3px; text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            box-shadow: 0 2px 4px rgba(0,0,0,0.4); transition: all 0.1s ease; letter-spacing: 0.5px;
        }
        button:hover { background: linear-gradient(to bottom, #454d5a, #363d48); transform: translateY(-1px); }
        button:active { transform: translateY(1px); background: #222; border-top: 1px solid #111; }
        button.active { background: var(--accent) !important; border-color: #2980b9 !important; box-shadow: 0 0 15px var(--accent-glow); text-shadow: none; }
        button.recording { background: var(--rec) !important; box-shadow: 0 0 15px var(--rec); border:1px solid #fff !important; }
        button.armed { background: var(--rec) !important; animation: flash 2s infinite; }
        @keyframes flash { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .data-font { font-size: 10px; letter-spacing: 1px; color: #666; font-family: monospace; font-weight: bold; }
        #status-led { width: 8px; height: 8px; border-radius: 50%; background: #333; box-shadow: inset 0 1px 2px rgba(0,0,0,0.5); }
        #status-led.online { background: #2ecc71; box-shadow: 0 0 8px #2ecc71; }
        *:focus { outline: none; }
        select { background: #16191f; color: #ccc; border: 1px solid #000; padding: 4px; border-radius: 3px; width: 100%; }
    </style>
</head>
<body>
<div id="chassis">
    <div id="top-bar" class="panel">
        <div class="ctrl-group">
            <div id="status-led"></div>
            <button id="pBtn" onclick="engine.toggle()" style="width:60px;">START</button>
            <button id="modeBtn" onclick="ui.toggleMode()">PAT</button>
            
            <div class="mini-slider-box">
                <label>BPM: <span id="bpm-val" style="color:#ccc">120</span></label>
                <input type="range" min="60" max="200" value="120" oninput="engine.bpm=this.value; document.getElementById('bpm-val').innerText=this.value">
            </div>
            <div class="mini-slider-box">
                <label>SWING</label>
                <input type="range" min="0" max="0.3" step="0.01" value="0" oninput="engine.swing=this.value">
            </div>
            <div class="mini-slider-box">
                <label>MASTER</label>
                <input type="range" min="0" max="1.5" step="0.01" value="1" oninput="engine.setMaster(this.value)">
            </div>
        </div>
        <div class="ctrl-group" style="display:flex; gap:10px; align-items:center;">
            <button id="armBtn" onclick="recorder.toggleArm()">ARM REC</button>
            <div id="rec-ui-hidden" style="display:none; gap:10px; align-items:center;">
                <a id="rec-dl" download="master_record.wav"><button>SAVE WAV</button></a>
            </div>
        </div>
        <div class="flex">
            <button onclick="io.exportSession()">EXP</button>
            <button onclick="document.getElementById('importInput').click()">IMP</button>
            <input type="file" id="importInput" style="display:none" onchange="io.importSession(this)">
            <button id="tSeq" class="active" onclick="ui.tab('seq')">SEQ</button>
            <button id="tMix" onclick="ui.tab('mix')">MIX</button>
        </div>
    </div>

    <div id="page-seq">
        <div id="bank-nav" class="panel"></div>

        <div id="track-rack-container">
            <div id="track-toolbar">
                <button onclick="engine.addTrack()">+ TRACK</button>
                <div class="flex" style="background: #111; border-radius: 3px; padding: 2px 5px; border:1px solid #000;">
                    <button onclick="engine.updateBankLength(-1)" style="padding: 2px 8px; height: 20px;">&lt;</button>
                    <span class="data-font" id="bank-len-disp" style="min-width:110px; text-align:center; line-height: 20px;">PAT 1 LEN: 16</span>
                    <button onclick="engine.updateBankLength(1)" style="padding: 2px 8px; height: 20px;">&gt;</button>
                </div>
            </div>

            <div id="timeline-header">
                <div></div>
                <div id="playhead-grid" class="step-grid"></div>
                <div></div>
                <div></div>
            </div>

            <div id="tracks-scroll-area">
                <div id="tracks-list"></div>
            </div>
        </div>

        <div id="song-arranger-panel" class="panel">
            <div class="data-font">SONG_ARRANGER</div>
            <div id="song-arranger-box">
                <button onclick="engine.addSongCell()">+ ADD</button>
                <button onclick="engine.removeSongCell()">- REM</button>
                <div style="width:1px; height:20px; background:#333; margin:0 10px;"></div>
                <div id="song-cells"></div>
            </div>
        </div>
    </div>

    <div id="page-mix">
        <div id="mixer-rack" class="mixer-rack"></div>
    </div>
</div>

<script>
// --- AUDIO UTILITIES (WAV ENCODING) ---
const audioUtils = {
    bufferToWav(buffer) {
        const numChannels = buffer.numberOfChannels;
        const sampleRate = buffer.sampleRate;
        
        let result;
        if (numChannels === 2) {
            result = this.interleave(buffer.getChannelData(0), buffer.getChannelData(1));
        } else {
            result = buffer.getChannelData(0);
        }

        return this.encodeWAV(result, numChannels, sampleRate);
    },
    interleave(l, r) {
        let len = l.length + r.length;
        let res = new Float32Array(len);
        let x = 0;
        for (let i = 0; i < l.length; i++) { res[x++] = l[i]; res[x++] = r[i]; }
        return res;
    },
    encodeWAV(samples, numChannels, sampleRate) {
        const buffer = new ArrayBuffer(44 + samples.length * 2);
        const view = new DataView(buffer);
        const writeString = (view, offset, string) => {
            for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
        };

        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + samples.length * 2, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * 2, true);
        view.setUint16(32, numChannels * 2, true);
        view.setUint16(34, 16, true);
        writeString(view, 36, 'data');
        view.setUint32(40, samples.length * 2, true);

        let offset = 44;
        for (let i = 0; i < samples.length; i++) {
            let s = Math.max(-1, Math.min(1, samples[i]));
            s = s < 0 ? s * 0x8000 : s * 0x7FFF;
            view.setInt16(offset, s, true);
            offset += 2;
        }
        return new Blob([view], { type: 'audio/wav' });
    }
};

// --- RECORDER ---
const recorder = {
    recording: false, armed: false, processor: null, left: [], right: [],
    toggleArm() {
        this.armed = !this.armed;
        const btn = document.getElementById('armBtn');
        if(this.armed) {
            btn.classList.add('armed'); btn.innerText = "WAITING...";
            document.getElementById('rec-ui-hidden').style.display = 'none';
        } else {
            btn.classList.remove('armed'); btn.classList.remove('recording'); btn.innerText = "ARM REC";
        }
    },
    start() {
        if(!this.armed) return;
        this.left = []; this.right = [];
        this.processor = engine.ctx.createScriptProcessor(4096, 2, 2);
        this.processor.connect(engine.ctx.destination);
        engine.master.connect(this.processor);
        this.processor.onaudioprocess = (e) => {
            if (!this.recording) return;
            this.left.push(new Float32Array(e.inputBuffer.getChannelData(0)));
            this.right.push(new Float32Array(e.inputBuffer.getChannelData(1)));
        };
        this.recording = true;
        const btn = document.getElementById('armBtn');
        btn.classList.remove('armed'); btn.classList.add('recording'); btn.innerText = "REC";
    },
    stop() {
        if(this.recording) {
            this.recording = false;
            if(this.processor) { this.processor.disconnect(); engine.master.disconnect(this.processor); }
            this.finish();
        }
    },
    finish() {
        const btn = document.getElementById('armBtn');
        btn.classList.remove('recording'); btn.innerText = "ARM REC";
        this.armed = false; 
        
        const merge = (b) => { let l=b.reduce((a,c)=>a+c.length,0), r=new Float32Array(l), o=0; b.forEach(c=>{r.set(c,o);o+=c.length}); return r; };
        const flatL = merge(this.left); 
        const flatR = merge(this.right);
        const interleaved = audioUtils.interleave(flatL, flatR);
        const wavBlob = audioUtils.encodeWAV(interleaved, 2, engine.ctx.sampleRate);
        
        const url = URL.createObjectURL(wavBlob);
        document.getElementById('rec-dl').href = url;
        document.getElementById('rec-ui-hidden').style.display = 'flex';
    }
};

// --- AUDIO ENGINE ---
const engine = {
    ctx: null, master: null, tracks: [], mixer: [], song: [0],
    bpm: 120, playing: false, step: 0, bank: 0, songIdx: 0, nextTime: 0, timer: null,
    bankLengths: Array(8).fill(16), swing: 0, 

    initChannels() {
        if (this.ctx) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AC();
        this.master = this.ctx.createGain();
        this.master.connect(this.ctx.destination);
        for(let i=0; i<8; i++) {
            const inp = this.ctx.createGain(); const out = this.ctx.createGain();
            inp.connect(out); out.connect(this.master);
            this.mixer.push({ input: inp, output: out, fx: [] });
        }
    },
    setMaster(v) { if(this.master) this.master.gain.value = v; },
    async toggle() {
        this.initChannels();
        if (this.ctx.state === 'suspended') await this.ctx.resume();
        this.playing = !this.playing;
        if (this.playing) {
            if(recorder.armed) recorder.start();
            this.nextTime = this.ctx.currentTime; this.scheduler();
        } else { this.stopAll(); }
        document.getElementById('pBtn').innerText = this.playing ? "STOP" : "START";
        document.getElementById('status-led').className = this.ctx.state === 'running' ? 'online' : '';
    },
    scheduler() {
        if (!this.playing) return;
        while (this.nextTime < this.ctx.currentTime + 0.1) {
            const activeBank = ui.mode === 'song' ? this.song[this.songIdx] : this.bank;
            this.playStep(this.step, this.nextTime, activeBank);
            this.nextTime += (60 / this.bpm / 4);
            this.step++;
            if(this.step >= this.bankLengths[activeBank]) {
                this.step = 0;
                if (ui.mode === 'song') {
                    this.songIdx = (this.songIdx + 1) % this.song.length;
                    requestAnimationFrame(() => ui.render());
                }
            }
        }
        this.timer = setTimeout(() => this.scheduler(), 25);
    },
    playStep(s, t, b) {
        const sw = (s % 2 !== 0) ? (this.swing * (60 / this.bpm / 4)) : 0;
        const time = t + sw;
        this.tracks.forEach(tr => {
            if (tr.buffer && tr.patterns[b][s]) {
                const ch = this.mixer[tr.bus];
                ch.fx.forEach(f => { if (f.trigger) f.trigger(time); });
                
                // MONO TRIGGER LOGIC
                if (tr.activeSource && tr.gainNode) {
                    tr.gainNode.gain.cancelAndHoldAtTime(time);
                    tr.gainNode.gain.exponentialRampToValueAtTime(0.0001, time + 0.005);
                    tr.activeSource.stop(time + 0.005);
                }
                const src = this.ctx.createBufferSource(); src.buffer = tr.buffer;
                const g = this.ctx.createGain();
                src.connect(g); g.connect(ch.input); src.start(time);
                tr.activeSource = src; tr.gainNode = g;
            }
        });
        requestAnimationFrame(() => ui.updatePlayhead(s));
    },
    stopAll() {
        clearTimeout(this.timer);
        if(recorder.recording) recorder.stop();
        this.step = 0; this.songIdx = 0;
        this.tracks.forEach(t => {
            if(t.activeSource && t.gainNode) {
                t.gainNode.gain.cancelAndHoldAtTime(this.ctx.currentTime);
                t.activeSource.stop(this.ctx.currentTime + 0.05);
            }
        });
        ui.render(); ui.updatePlayhead(0);
    },
    rebuildChain(i) {
        const ch = this.mixer[i]; ch.input.disconnect(); 
        ch.fx.forEach(f => { if(f.output) f.output.disconnect(); });
        let p = ch.input;
        if (ch.fx.length > 0) ch.fx.forEach(f => { if (f.input && f.output) { p.connect(f.input); p = f.output; } });
        p.connect(ch.output);
    },
    async injectFX(chIdx, file, codeOverride = null, state = null) {
        this.initChannels();
        try {
            const code = codeOverride || await file.text();
            const blob = new Blob([code], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            const mod = await import(url + '#' + Date.now());
            const inst = new (mod.default || Object.values(mod)[0])(this.ctx);
            inst._sourceCode = code;
            
            // RESTORE STATE
            if (state && inst.setState) inst.setState(state);
            
            this.mixer[chIdx].fx.push(inst);
            this.rebuildChain(chIdx);
            ui.renderMixer();
        } catch (e) { console.error("FX Load Error", e); }
    },
    removeFX(c, f) { this.mixer[c].fx.splice(f, 1); this.rebuildChain(c); ui.renderMixer(); },
    addTrack() {
        this.tracks.push({ 
            id: Date.now()+Math.random(), buffer: null, fileName: "EMPTY", bus: 0, activeSource: null, gainNode: null,
            patterns: Array.from({length:8}, () => Array(32).fill(false)) 
        });
        ui.render();
    },
    addSongCell() { this.song.push(0); ui.render(); },
    removeSongCell() { if(this.song.length > 1) { this.song.pop(); ui.render(); } },
    updateBankLength(dir) {
        let val = this.bankLengths[this.bank] + (dir * 4);
        this.bankLengths[this.bank] = Math.max(4, Math.min(32, val));
        ui.render();
    }
};

// --- UI LOGIC ---
const ui = {
    mode: 'pattern',
    tab(name) {
        engine.initChannels();
        document.getElementById('page-seq').style.display = name === 'seq' ? 'flex' : 'none';
        document.getElementById('page-mix').style.display = name === 'mix' ? 'flex' : 'none';
        document.getElementById('tSeq').className = name === 'seq' ? 'active' : '';
        document.getElementById('tMix').className = name === 'mix' ? 'active' : '';
        if(name === 'mix') this.renderMixer();
    },
    toggleMode() {
        this.mode = (this.mode === 'pattern') ? 'song' : 'pattern';
        document.getElementById('modeBtn').innerText = this.mode === 'pattern' ? 'PAT' : 'SONG';
        this.render();
    },
    render() {
        const b = (this.mode === 'song') ? engine.song[engine.songIdx] : engine.bank;
        const list = document.getElementById('tracks-list'); if(!list) return;
        document.getElementById('bank-len-disp').innerText = `PAT ${b+1} LEN: ${engine.bankLengths[b]}`;
        list.innerHTML = '';
        
        const ph = document.getElementById('playhead-grid'); ph.innerHTML = '';
        for(let i=0; i<32; i++) ph.innerHTML += `<div class="playhead-slot"></div>`;
        
        engine.tracks.forEach((t, i) => {
            const row = document.createElement('div'); row.className = 'track-row';
            row.innerHTML = `
                <div><button onclick="this.nextElementSibling.click()">LOAD</button><input type="file" style="display:none" onchange="ui.loadSmp(${t.id}, this)"><div class="data-font" style="font-size:8px; margin-top:2px;">${t.fileName}</div></div>
                <div class="step-grid" id="grid-${t.id}"></div>
                <select class="data-font" onchange="engine.tracks[${i}].bus=this.value; engine.rebuildChain(this.value)">
                    ${engine.mixer.map((_,m)=>`<option value="${m}" ${t.bus==m?'selected':''}>CH ${m+1}</option>`).join('')}
                </select>
                <button onclick="engine.tracks.splice(${i},1);ui.render()" style="color:var(--danger)">X</button>`;
            list.appendChild(row);
            const grid = document.getElementById(`grid-${t.id}`);
            for(let s=0; s<32; s++) {
                const step = document.createElement('div');
                step.className = `step ${t.patterns[b][s] ? 'on' : ''} ${s % 4 === 0 ? 'beat-mark' : ''}`;
                step.style.opacity = s >= engine.bankLengths[b] ? "0.1" : "1";
                step.onclick = () => { if(s < engine.bankLengths[b]) { t.patterns[b][s] = !t.patterns[b][s]; step.classList.toggle('on'); } };
                grid.appendChild(step);
            }
        });
        this.renderBanks(); this.renderSong();
    },
    renderMixer() {
        const rack = document.getElementById('mixer-rack'); if(!rack) return;
        rack.innerHTML = '';
        engine.mixer.forEach((ch, i) => {
            const strip = document.createElement('div'); strip.className = 'mixer-strip';
            strip.innerHTML = `<div class="data-font" style="text-align:center; padding-bottom:5px; border-bottom:1px solid #333">CH ${i+1}</div><div class="fx-stack"></div><button onclick="this.nextElementSibling.click()">+ FX</button><input type="file" style="display:none" onchange="engine.injectFX(${i}, this.files[0])"><div class="data-font" style="margin-top:10px">VOL</div><input type="range" min="0" max="1.5" step="0.01" value="${ch.output.gain.value}" oninput="engine.mixer[${i}].output.gain.value=this.value">`;
            rack.appendChild(strip);
            const stack = strip.querySelector('.fx-stack');
            ch.fx.forEach((fx, idx) => {
                const box = document.createElement('div'); box.style.border = "1px solid #444"; box.style.marginBottom="5px"; box.style.background="#000";
                if(fx.renderUI) fx.renderUI(box, () => engine.removeFX(i, idx));
                stack.appendChild(box);
            });
        });
    },
    async loadSmp(id, el) {
        engine.initChannels();
        const tr = engine.tracks.find(t => t.id === id);
        const file = el.files[0]; if(!file) return;
        tr.fileName = file.name.substring(0, 10);
        const ab = await file.arrayBuffer();
        tr.buffer = await engine.ctx.decodeAudioData(ab);
        ui.render();
    },
    updatePlayhead(s) {
        const ph = document.getElementById('playhead-grid');
        if(ph && ph.children[s]) {
            Array.from(ph.children).forEach(c => c.classList.remove('active'));
            ph.children[s].classList.add('active');
        }
    },
    renderBanks() {
        const nav = document.getElementById('bank-nav'); if(!nav) return;
        nav.innerHTML = '';
        const cur = (this.mode === 'song') ? engine.song[engine.songIdx] : engine.bank;
        for(let i=0; i<8; i++) {
            const btn = document.createElement('button'); btn.innerText = i+1;
            btn.className = (cur === i) ? 'active' : '';
            btn.onclick = () => { this.mode = 'pattern'; engine.bank = i; this.render(); };
            nav.appendChild(btn);
        }
    },
    renderSong() {
        const cont = document.getElementById('song-cells'); if(!cont) return; 
        cont.innerHTML = '';
        engine.song.forEach((bank, idx) => {
            const cell = document.createElement('button'); cell.innerText = bank + 1;
            if(this.mode === 'song' && engine.songIdx === idx) cell.classList.add('active');
            cell.onclick = () => { engine.song[idx] = (engine.song[idx] + 1) % 8; ui.renderSong(); };
            cont.appendChild(cell);
        });
    }
};

// --- ROBUST IO MANAGER ---
const io = {
    async exportSession() {
        engine.initChannels();
        const zip = new JSZip();
        const samplesFolder = zip.folder("samples");
        
        // 1. Save Patterns & Metadata
        const tracksMeta = engine.tracks.map(t => {
            return {
                id: t.id,
                bus: t.bus,
                patterns: t.patterns,
                fileName: t.fileName,
                hasSample: !!t.buffer // Flag to know if we should look for audio data
            };
        });

        // 2. Save Physical Audio Samples
        engine.tracks.forEach(t => {
            if (t.buffer) {
                // Convert AudioBuffer to WAV Blob
                const wavBlob = audioUtils.bufferToWav(t.buffer);
                samplesFolder.file(`${t.id}.wav`, wavBlob);
            }
        });

        // 3. Save Mixer & Plugins
        const mixerData = engine.mixer.map(m => ({ 
            gain: m.output.gain.value, 
            fxData: m.fx.map(f => ({
                code: f._sourceCode || "",
                state: (f.getState) ? f.getState() : null 
            })) 
        }));

        const projectData = {
            version: "5.5",
            bpm: engine.bpm, 
            bankLengths: engine.bankLengths, 
            song: engine.song, 
            swing: engine.swing,
            tracks: tracksMeta,
            mixer: mixerData
        };

        zip.file("project.json", JSON.stringify(projectData));
        
        const blob = await zip.generateAsync({type:"blob"});
        const a = document.createElement('a'); 
        a.href = URL.createObjectURL(blob); 
        a.download = "megaproject.daw"; 
        a.click();
    },

    async importSession(el) {
        if(!el.files[0]) return;
        engine.initChannels();
        
        const btn = el.previousElementSibling;
        const originalText = btn.innerText;
        btn.innerText = "LOADING...";
        
        try {
            const zip = await JSZip.loadAsync(el.files[0]);
            const jsonStr = await zip.file("project.json").async("string");
            const data = JSON.parse(jsonStr);
            
            // Restore Global Settings
            engine.bpm = data.bpm || 120;
            engine.bankLengths = data.bankLengths || Array(8).fill(16);
            engine.song = data.song || [0];
            engine.swing = data.swing || 0;
            
            // Restore Tracks
            engine.tracks = []; // Clear current
            
            for (const tMeta of data.tracks) {
                let newBuffer = null;
                // If the track had a sample, try to find it in the zip
                if (tMeta.hasSample) {
                    const sampleFile = zip.file(`samples/${tMeta.id}.wav`);
                    if (sampleFile) {
                        const arrayBuffer = await sampleFile.async("arraybuffer");
                        newBuffer = await engine.ctx.decodeAudioData(arrayBuffer);
                    }
                }
                
                engine.tracks.push({
                    id: tMeta.id,
                    bus: tMeta.bus,
                    patterns: tMeta.patterns,
                    fileName: tMeta.fileName,
                    buffer: newBuffer,
                    activeSource: null,
                    gainNode: null
                });
            }

            // Restore Mixer & Plugins
            engine.mixer.forEach(m => { m.fx = []; m.output.gain.value = 1; });
            
            if (data.mixer) {
                for (let i = 0; i < 8; i++) {
                    if (data.mixer[i]) {
                        engine.mixer[i].output.gain.value = data.mixer[i].gain;
                        const fxList = data.mixer[i].fxData || data.mixer[i].fxCodes || [];
                        
                        for (const item of fxList) {
                            const code = typeof item === 'string' ? item : item.code;
                            const state = typeof item === 'object' ? item.state : null;
                            if (code && code.length > 0) {
                                await engine.injectFX(i, null, code, state);
                            }
                        }
                    }
                }
            }

            ui.render();
            btn.innerText = "IMP";
        } catch (e) {
            console.error("Import Failed:", e);
            alert("Corrupt or incompatible session file.");
            btn.innerText = "ERROR";
        }
    }
};

// Start
for(let i=0;i<4;i++) engine.addTrack();
</script>
</body>
</html>
